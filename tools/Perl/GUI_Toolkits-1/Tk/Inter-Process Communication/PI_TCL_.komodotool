{
  "keyboard_shortcut": "", 
  "name": "PI (TCL)", 
  "value": [
    "#!/usr/local/bin/wish", 
    "#", 
    "# Compute pi using a simple parallel message passing scheme.  This code", 
    "# is the master and runs in processor zero.  We fire up code in multiple", 
    "# processors that share in the computational task, and tell them their", 
    "# processor number, the total number of processors, and the interval", 
    "# we want to integrate.  The processors sum their portion of the interval,", 
    "# and send() it back to processor zero, the master, where we sum reduce", 
    "# the results.", 
    "", 
    "global helper intervals numprocs pids proc sums", 
    "", 
    "proc compute_pi {} {", 
    "", 
    "    global helper intervals numprocs pids proc sums", 
    "", 
    "    status \"\\n===== $intervals intervals, $numprocs processors\"", 
    "    start_helpers_calculating;", 
    "    do_my_part;", 
    "    set pi [sum_reduce];", 
    "    status \"\\nComputed pi = [format \"%22.20f\" $pi]\"", 
    "    set actual_pi 3.14159265358979323846", 
    "    status \"Actual   pi = $actual_pi\"", 
    "    status \"Error       = [format \"%22.20f\" [expr abs($pi - $actual_pi)]]\"", 
    "", 
    "}; # end compute_pi", 
    "", 
    "proc create_interface {} {", 
    "", 
    "    wm geometry . \"+100+100\"", 
    "    wm title . \"Compute pi Using Multiple Processors\"", 
    "    wm iconname . \"pi\"", 
    "", 
    "    # Create menubar, menubuttons, menus and callbacks.", 
    "", 
    "    menu .mb", 
    "    . configure -menu .mb", 
    "", 
    "    .mb add cascade -label File -underline 0 -menu .mb.file", 
    "    menu .mb.file", 
    "    .mb.file add command -label Quit -command {destroy .}", 
    "", 
    "    # Frame to hold itervals label and entry widgets.", 
    "", 
    "    frame .f", 
    "    pack .f -fill x", 
    "    label .f.s -text \"Intervals: \"", 
    "    entry .f.e -width 25 -textvariable intervals", 
    "    pack .f.s -side left", 
    "    pack .f.e -side right", 
    "", 
    "    # Frame to hold number of processors label and entry widgets.", 
    "", 
    "    frame .f2", 
    "    pack .f2 -fill x", 
    "    label .f2.s -text \"Processors: \"", 
    "    entry .f2.e -width 25 -textvariable numprocs", 
    "    pack .f2.s -side left", 
    "    pack .f2.e -side right", 
    "", 
    "    # Text widget to hold results.", 
    "", 
    "    text .t -width 50 -height 14", 
    "    pack .t -fill both -expand 1", 
    "", 
    "    button .c -text Compute -command {compute_pi}", 
    "    pack .c", 
    "", 
    "}; # end create_interface", 
    "", 
    "proc do_my_part {} {", 
    "", 
    "    # All helpers are started, do our part of the computation.", 
    "", 
    "    global helper intervals numprocs pids proc sums", 
    "", 
    "    status \"Master processor $proc starting its computation.\"", 
    "", 
    "    set h [expr 1.0 / $intervals]", 
    "    set sums($proc) 0", 
    "", 
    "    for {set i [expr $proc + 1]} {$i <= $intervals} {incr i $numprocs} {", 
    "\tset x [expr $h * ($i - 0.5)]", 
    "\tset sums($proc) [expr $sums($proc) +  4.0 / (1.0 + $x*$x)]", 
    "    }", 
    "    set sums($proc) [expr $h * $sums($proc)]", 
    "    status \"\\nMaster processor $proc partial sum = $sums($proc).\"", 
    "", 
    "}; # end do_my_part", 
    "", 
    "proc init {} {", 
    "", 
    "    global helper intervals numprocs pids proc sums", 
    "    global wishexe", 
    "", 
    "    set helper \"pihelp.tcl\"", 
    "    set intervals 1000", 
    "    set numprocs 3", 
    "    set proc 0", 
    "    set wishexe \"/usr/local/bin/wish\"", 
    "", 
    "}; # end init", 
    "", 
    "proc start_helpers_calculating {} {", 
    "", 
    "    global helper intervals numprocs pids proc sums", 
    "    global wishexe", 
    "", 
    "    set proc [expr $numprocs - 1]", 
    "    set y 420", 
    "    while {$proc > 0} {", 
    "\tset pids($proc) [exec $wishexe -name pihelp${proc} \\", 
    "\t\t-geometry +100+${y} < $helper &]", 
    "\tstatus \"Helper processor $proc started, pid=$pids($proc).\"", 
    "\tincr y 50", 
    "\tincr proc [expr -1]", 
    "    }", 
    "    after 2000", 
    "", 
    "    set proc [expr $numprocs - 1]", 
    "    while {$proc > 0} {", 
    "\tsend pihelp${proc} \"set numprocs $numprocs; \\", 
    "\t\tset proc $proc; set intervals $intervals\"", 
    "\tincr proc [expr -1]", 
    "    }", 
    "", 
    "}; # end start_helpers_calculating", 
    "", 
    "proc status {msg} {", 
    "", 
    "    .t insert end \"$msg\\n\"", 
    "    .t yview end", 
    "    update idletasks", 
    "", 
    "}; # end status", 
    "", 
    "proc sum_reduce {} {", 
    "", 
    "    # Do a sum reduction.  Fetch all the partial sums computed", 
    "    # by the helper processors, and then add them to our partial", 
    "    # sum.  The result is an approximation of pi.", 
    "", 
    "    global helper intervals numprocs pids proc sums", 
    "", 
    "    set pi 0", 
    "    for {set proc 1} {$proc < $numprocs} {incr proc} {", 
    "\ttkwait variable sums($proc)", 
    "\tstatus \"Partial sum from processor $proc = $sums($proc).\"", 
    "\tset pi [expr $pi + $sums($proc)]", 
    "\texec kill $pids($proc)", 
    "    }", 
    "    return [expr $pi + $sums(0)]", 
    "", 
    "}; # end sum_reduce", 
    "", 
    "# main", 
    "", 
    "init", 
    "create_interface!@#_currentPos!@#_anchor"
  ], 
  "set_selection": "false", 
  "version": "1.0.12", 
  "treat_as_ejs": "false", 
  "type": "snippet", 
  "indent_relative": "false", 
  "auto_abbreviation": "false"
}