{
  "keyboard_shortcut": "", 
  "name": "xneko", 
  "value": [
    "#!/usr/local/bin/perl -w", 
    "#", 
    "# A Perl/TK version of Masayuki Koba's xneko game.", 
    "#", 
    "# Stephen.O.Lidie@Lehigh.EDU.  2000/01/07", 
    "", 
    "use Tk;", 
    "use File::Basename;", 
    "use POSIX qw/acos/;", 
    "use subs qw/do_awake do_move do_sleep do_stop do_togi frame", 
    "    go_neko init position_to_heading set_state stopped/;", 
    "use vars qw/$akubi_time $awake_time $canvas $close_enough %dxdy", 
    "    $jare_time $kaki_time $maxx $maxy $mw $nx $ny $pi $pix $pixbits @pixlist", 
    "    %pixmaps $r2d $rx $ry $state %states $state_count $stop_time $togi_time", 
    "    $velocity $x $y $where/;", 
    "use strict;", 
    "", 
    "$mw = new MainWindow;", 
    "init;", 
    "$mw->repeat(100 => \\&go_neko);", 
    "MainLoop;", 
    "", 
    "sub go_neko {", 
    "", 
    "    # This \"mainloop\" dispatches control to one of 5 state processors,", 
    "    # each of which displays pixmaps based on the state's cycle count.", 
    "", 
    "    $state_count++;\t\t# current state's cycle count", 
    "    $where = sprintf(\"state=%-7s state_count=%05d, nx=%04d, ny=%04d\",", 
    "\t\t     $state, $state_count, $nx, $ny);", 
    "", 
    "  STATES:", 
    "    foreach my $regex (keys %states) {", 
    "\tnext STATES unless $state =~ /^($regex)$/;", 
    "\t&{$states{$regex}}($1);", 
    "\treturn;", 
    "    }", 
    "", 
    "} # end go_neko", 
    "", 
    "sub frame {", 
    "", 
    "    # Display an animation frame.", 
    "", 
    "    if ( ($Tk::VERSION cmp '800.018') < 0 ) {", 
    "\t$canvas->coords($pixmaps{$pix}, -1000, -1000);", 
    "    } else {", 
    "\t$canvas->itemconfigure($pixmaps{$pix}, -state => 'hidden');", 
    "    }", 
    "    $pix = \"$_[0].ppm\";", 
    "    $canvas->coords($pixmaps{$pix}, $nx, $ny);", 
    "    if ( ($Tk::VERSION cmp '800.018') >= 0 ) {", 
    "\t$canvas->itemconfigure($pixmaps{$pix}, -state => 'normal');", 
    "    }", 
    "", 
    "} # end frame", 
    "", 
    "sub init {", 
    "", 
    "    my $image_base = './images';", 
    "    my $cursor = $^O eq 'MSWin32' ? 'mouse' :", 
    "\t[\"\\@$image_base/mouse.xbm\", \"$image_base/mouse.mask\", qw/brown white/];", 
    "    ($maxx, $maxy) = (400,400);", 
    "", 
    "    $canvas = $mw->Canvas(", 
    "        -width      => $maxx,", 
    "        -height     => $maxy,", 
    "        -background => 'white',", 
    "        -cursor     => $cursor,", 
    "    );", 
    "    $canvas->pack(qw/-fill both -expand yes/);", 
    "", 
    "    $mw->Scale(qw/", 
    "        -background         white ", 
    "        -from               0", 
    "        -to                 20", 
    "        -showvalue          1", 
    "        -resolution         1", 
    "        -orient             horizontal", 
    "        -relief             flat", 
    "\t-font               fixed ", 
    "\t-highlightthickness 0", 
    "\t/,", 
    "        -variable => \\$velocity,", 
    "    )->pack(qw/-fill both -expand yes/);", 
    "", 
    "    $mw->Button(", 
    "        -text => 'Quit',", 
    "        -command => \\&exit,", 
    "    )->pack(-side => 'left');", 
    "", 
    "    $mw->Label(", 
    "        -textvariable => \\$where,", 
    "        qw/", 
    "        -background white", 
    "\t-font fixed", 
    "        /,", 
    "    )->pack(qw/-side right -fill both -expand yes/);", 
    "", 
    "    $canvas->update;", 
    "    ", 
    "    $pi = acos(-1);\t\t# pi", 
    "    $r2d = 180.0 / $pi;\t\t# radians to degrees", 
    "    ($nx, $ny) = ($maxx/2, $maxy/2 + 80); # current neko position", 
    "    ($rx, $ry) = ($canvas->rootx, $canvas->rooty);", 
    "    $velocity = 10;\t\t# in pixels/cycle", 
    "", 
    "    $close_enough = 5;\t\t# neko has caught mouse if within", 
    "                                # this pixel distance", 
    "    %dxdy = (", 
    "        LEFT    => [-1,  0],", 
    "\tRIGHT   => [+1,  0],", 
    "        UP      => [ 0, -1],", 
    "        DOWN    => [ 0, +1],", 
    "        DWLEFT  => [-1, +1],", 
    "        DWRIGHT => [+1, +1],", 
    "        UPLEFT  => [-1, -1],", 
    "        UPRIGHT => [+1, -1],", 
    "    );\t\t\t\t# x/y pixel delta multipliers", 
    "    $pix = '';\t\t\t# currently displayed Pixmap", 
    "    $pixbits = 16;\t\t# 0.5 Pixmap size in bits", 
    "    $state = '';\t\t# current game state", 
    "    %states = (", 
    "        qr/AWAKE/                   => \\&do_awake,", 
    "        qr/UP|UPRIGHT|RIGHT|DWRIGHT|DOWN|DWLEFT|LEFT|UPLEFT/ => \\&do_move,", 
    "        qr/STOP/                    => \\&do_stop,", 
    "        qr/UTOGI|RTOGI|DTOGI|LTOGI/ => \\&do_togi,", 
    "        qr/SLEEP/                   => \\&do_sleep,", 
    "    );\t\t\t\t# neko state table", 
    "    $state_count = 0;\t\t# current state's cycle count", 
    "    set_state 'AWAKE';", 
    "    $akubi_time =  3 * 2;\t# yawn cycles", 
    "    $awake_time =  3 * 2;\t# awake cycles", 
    "    $jare_time  = 10 * 2;\t# stomp cycles", 
    "    $kaki_time  =  4 * 2;\t# scratch neko cycles", 
    "    $stop_time  =  4 * 2;\t# stop cycles", 
    "    $togi_time  = 10 * 2;\t# scratch wall cycles", 
    "", 
    "    # Load and momentarily display Pixmaps (probably poor Japanese", 
    "    # translations my own).", 
    "    #", 
    "    # Icon        - neko icon", 
    "    # awake       - freshly awake", 
    "    # down1       - south #1", 
    "    # down2       - south #2", 
    "    # dtogi1      - south wall scratch #1", 
    "    # dtogi2      - south wall scratch #2", 
    "    # dwleft1     - southwest #1", 
    "    # dwleft2     - southwest #2", 
    "    # dwright1    - southeast #1", 
    "    # dwright2    - southeast #2", 
    "    # jare2       - stopped #2 (stomp ground)", 
    "    # kaki1       - scratch #1", 
    "    # kaki2       - scratch #2", 
    "    # left1       - west #1", 
    "    # left2       - west #2", 
    "    # ltogi1      - west wall scratch #1", 
    "    # ltogi2      - west wall scratch #2", 
    "    # mati2       - stopped #1", 
    "    # mati3       - yawn", 
    "    # rtogi1      - east wall scratch #1", 
    "    # rtogi2      - east wall scratch #2", 
    "    # sleep1      - sleep #1", 
    "    # sleep2      - sleep #2", 
    "    # north1      - north #1", 
    "    # north2      - north #2", 
    "    # upleft1     - northwest #1", 
    "    # upleft2     - northwest #2", 
    "    # upright1    - northeast #1", 
    "    # upright2    - northeast #2", 
    "    # utogi1      - north wall scratch #1", 
    "    # utogi2      - north wall scratch #2", 
    "", 
    "    my $x = 40;", 
    "    my $y = 30;", 
    "    my $i = $canvas->createText(120, 20, -fill => 'black',", 
    "        -text => \"Loading pixmaps ...\");", 
    "    my $n = 1;", 
    "    foreach my $pfn ( <$image_base/*.ppm> ) {", 
    "\tmy $bpfn = basename $pfn;", 
    "\t$pixmaps{$bpfn} = $canvas->createImage($x, $y,", 
    "            -image => $canvas->Photo(-file => $pfn));", 
    "\t$canvas->idletasks;", 
    "\t$x += 35;", 
    "\tif ($n++ >= 8 or $bpfn eq 'Icon.ppm') {", 
    "\t    $y += 50;", 
    "\t    $x  = 40;", 
    "\t    $n = 1;", 
    "\t}", 
    "\t$canvas->after(50);", 
    "    } # forend all Pixmaps", 
    "    ", 
    "    # Hide Pixmaps off-canvas until we need them.", 
    "    ", 
    "    $canvas->delete($i);", 
    "    $canvas->after(1000);", 
    "    foreach my $pxid (keys %pixmaps) {", 
    "\tif ( ($Tk::VERSION cmp '800.018') < 0 ) {", 
    "\t    $canvas->coords($pixmaps{$pxid}, -1000, -1000);", 
    "\t} else {", 
    "\t    $canvas->itemconfigure($pixmaps{$pxid}, -state => 'hidden');", 
    "\t}", 
    "\t$canvas->idletasks;", 
    "\t$canvas->after(50);", 
    "    }", 
    "    ", 
    "} # end init", 
    "", 
    "sub position_to_heading {", 
    "", 
    "    # Swiped and modified from my TclRobots entry #2, position_to_heading()", 
    "    # determines the direction (as one of eight cardinal compass points) from", 
    "    # the neko to the mouse.  0 degress at three o'clock, moving clockwise.", 
    "", 
    "    ($x, $y) = $canvas->pointerxy;", 
    "    ($x, $y) = ($x - $rx, $y - $ry);", 
    "    $y -= ($pixbits / 2 + 3 );", 
    "", 
    "    # Don't let the neko run off the display.", 
    "", 
    "    if ($x < 0 + $pixbits) {", 
    "\t$x = $pixbits;", 
    "    } elsif ($x > $maxx - $pixbits) {", 
    "\t$x = $maxx - $pixbits;", 
    "    }", 
    "    if ($y < 0 + $pixbits) {", 
    "\t$y = $pixbits;", 
    "    } elsif ($y > $maxy - $pixbits) {", 
    "\t$y = $maxy - $pixbits;", 
    "    }", 
    "    return if stopped;", 
    "", 
    "    # Return heading from the neko to the mouse.", 
    "", 
    "    my $h = int( $r2d * atan2( ($y - $ny), ($x - $nx) ) ) % 360;", 
    "    my($degrees, $dir);", 
    "", 
    "    foreach (", 
    "\t     [[ 22.5,  67.5], 'DWRIGHT'],", 
    "\t     [[ 67.5, 112.5], 'DOWN'],", 
    "\t     [[112.5, 157.5], 'DWLEFT'],", 
    "\t     [[157.5, 202.5], 'LEFT'],", 
    "\t     [[202.5, 247.5], 'UPLEFT'],", 
    "\t     [[247.5, 292.5], 'UP'],", 
    "\t     [[292.5, 337.5], 'UPRIGHT'],", 
    "\t     [[337.5,  22.5], 'RIGHT'],", 
    "\t     ) {", 
    "\t($degrees, $dir) = ($_->[0], $_->[1]);", 
    "\tlast if $h >= $degrees->[0] and $h < $degrees->[1];", 
    "    } # forend", 
    "", 
    "    set_state $dir;", 
    "", 
    "} # end positition_to_heading", 
    "", 
    "sub set_state {", 
    "", 
    "    # Initialize for a new state if it's different from the current state.", 
    "", 
    "    my($new_state) = @_;", 
    "", 
    "    return if $new_state eq $state;", 
    "    $state = $new_state;", 
    "    $state_count = 0;", 
    "", 
    "} # end set_state", 
    "", 
    "sub stopped {", 
    "", 
    "    # See if the neko and mouse are close enough to pretend we are stopped.", 
    "    # $close_enough is tied to the neko's velocity to prevent \"directional", 
    "    # hysteresis\".", 
    "", 
    "    $close_enough = $velocity;", 
    "    (abs($x - $nx) <= $close_enough and abs($y - $ny) <= $close_enough) ? 1 : 0;", 
    "", 
    "} # end stopped", 
    "", 
    "# Neko state processors.", 
    "", 
    "sub do_awake {", 
    "", 
    "    frame 'awake';", 
    "    return if $state_count < $awake_time;", 
    "    position_to_heading;", 
    "", 
    "} # end do_awake", 
    "", 
    "sub do_move {", 
    "", 
    "    my($dir) = @_;", 
    "    if (stopped) {", 
    "\t($nx, $ny) = ($x, $y);", 
    "\tset_state 'STOP';", 
    "    } else {", 
    "\tmy($dx, $dy) = @{$dxdy{$dir}};", 
    "\t($nx, $ny) = ($nx + ($dx * $velocity), $ny + ($dy * $velocity));", 
    "\tframe lc($dir) . (($state_count % 2) + 1);", 
    "\tposition_to_heading;", 
    "    }", 
    "", 
    "} # end do_move", 
    "", 
    "sub do_sleep {", 
    "", 
    "    position_to_heading;", 
    "    if (stopped) {", 
    "\tif ($state_count < $jare_time) {", 
    "\t    frame (($state_count % 2) ? 'jare2' : 'mati2');", 
    "\t} elsif ($state_count < $jare_time + $kaki_time) {", 
    "\t    frame 'kaki' . (($state_count % 2) + 1);", 
    "\t} elsif ($state_count < $jare_time + $kaki_time + $akubi_time) {", 
    "\t    frame 'mati3';", 
    "\t} else {", 
    "\t    frame 'sleep' . ((($state_count % 8) <= 3) ? '1' : '2');", 
    "\t}", 
    "    } else {", 
    "\tset_state 'AWAKE';", 
    "    }", 
    "", 
    "} # end do_sleep", 
    "", 
    "sub do_stop {", 
    "", 
    "    if (stopped) {", 
    "\tif ($state_count < $stop_time) {", 
    "\t    frame 'mati2';", 
    "\t} elsif ($nx <= 0 + $pixbits) {", 
    "\t    set_state 'LTOGI';", 
    "\t} elsif ($nx >= $maxx - $pixbits) {", 
    "\t    set_state 'RTOGI';", 
    "\t} elsif ($ny <= 0 + $pixbits) {", 
    "\t    set_state 'UTOGI';", 
    "\t} elsif ($ny >= $maxy - $pixbits) {", 
    "\t    set_state 'DTOGI';", 
    "\t} else {", 
    "\t    set_state 'SLEEP';", 
    "\t}", 
    "    } else {", 
    "\tset_state 'AWAKE';", 
    "    }", 
    "", 
    "} # end do_stop", 
    "", 
    "sub do_togi {", 
    "", 
    "    my($dir) = @_;", 
    "", 
    "    position_to_heading;", 
    "    if (stopped) {", 
    "\tif ($state_count < $togi_time) {", 
    "\t    frame lc($dir) . (($state_count % 2) + 1);", 
    "\t} elsif ($state_count < $togi_time + $kaki_time) {", 
    "\t    frame 'kaki' . (($state_count % 2) + 1);", 
    "\t} elsif ($state_count < $togi_time + $kaki_time + $akubi_time) {", 
    "\t    frame 'mati3';", 
    "\t} else {", 
    "\t    frame 'sleep' . ((($state_count % 8) <= 3) ? '1' : '2');", 
    "\t}", 
    "    } else {", 
    "\tset_state 'AWAKE';", 
    "    }", 
    "", 
    "} # end do_togi", 
    "", 
    "1;!@#_currentPos!@#_anchor"
  ], 
  "set_selection": "false", 
  "version": "1.0.12", 
  "treat_as_ejs": "false", 
  "type": "snippet", 
  "indent_relative": "false", 
  "auto_abbreviation": "false"
}