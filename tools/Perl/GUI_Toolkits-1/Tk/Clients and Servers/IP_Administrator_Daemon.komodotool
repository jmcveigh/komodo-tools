{
  "keyboard_shortcut": "", 
  "name": "IP Administrator Daemon", 
  "value": [
    "#!/usr/local/bin/perl -w", 
    "# ", 
    "# ipadmd - IP administrator daemon.", 
    "#", 
    "# This network daemon serves subnet database files to authorized clients,", 
    "# which the clients modify via a Perl/Tk interface, and send back here.", 
    "# Periodically, it compares the last modification dates of the subnet files", 
    "# against an SDBM file, and updates the network DHCP and DNS files to", 
    "# reflect the recent changes.", 
    "#", 
    "# S. O. Lidie, 1999/07/15", 
    "", 
    "use 5.005;", 
    "use IPADM;", 
    "use Fcntl qw/:DEFAULT/;", 
    "use IO::Handle;", 
    "use IO::Socket;", 
    "use LockFile;", 
    "use POSIX qw/setsid/;", 
    "use SDBM_File;", 
    "use Net::hostent;", 
    "use subs qw/client_connect free_file kid update_network_dbs/;", 
    "use subs qw/gsl gsf psf usf/;\t# IPADM command processors", 
    "use vars qw/%LOCKS %MODTIMES/;", 
    "use strict;", 
    "", 
    "# Daemonize ourselves, setup signal handlers, open the server socket", 
    "# and our log file, tie the last modification date DB and start its", 
    "# associated timer, and, finally, enter the main accept loop.", 
    "", 
    "my $pid = fork;", 
    "die \"fork failed: $!\" unless defined $pid;", 
    "exit if $pid;\t\t\t# parent exits, daemon continues", 
    "setsid or die \"setsid failed: $!\";", 
    "", 
    "$SIG{ALRM} = \\&update_network_dbs;", 
    "", 
    "$SIG{CHLD} = sub {wait};", 
    "$SIG{TERM} = sub {untie %MODTIMES; exit};", 
    "", 
    "my $server = IO::Socket::INET->new(", 
    "    Proto     => 'tcp',", 
    "    LocalHost => $DAEMON_HOST,", 
    "    LocalPort => $DAEMON_PORT,", 
    "    Listen    => SOMAXCONN,", 
    "    Reuse => 1,", 
    ");", 
    "", 
    "die \"Socket::INET::new failed: $!\" unless defined $server;", 
    "open L, '>ipadmd.log' or die \"Cannot open ipadmd.log:  $!\";", 
    "L->autoflush(1);", 
    "", 
    "tie %MODTIMES, 'SDBM_File', $MOD_DB_PATH, O_RDWR|O_CREAT, 0644;", 
    "alarm 60;", 
    "", 
    "while (my $ns = $server->accept) {", 
    " ", 
    "    my $pid = undef;", 
    "    if ($pid = fork) {", 
    "        close $ns or die \"Client socket close failed: $!\";", 
    "    } elsif (defined $pid) {", 
    "        $ns->autoflush(1);", 
    "        client_connect $ns;", 
    "    } else {", 
    "        die \"fork error: $!\";", 
    "    }", 
    "    ", 
    "} # whilend forever network daemon", 
    "", 
    "sub client_connect {", 
    "", 
    "    # Process a client connect to update subnet database files. ", 
    "    # Log the remote host, and if they're authorized, read the", 
    "    # socket data until EOI and pass it to the proper command", 
    "    # processor.  Repeat as required.", 
    "", 
    "    my($ns) = @_;", 
    "", 
    "    my $peeraddr = $ns->peeraddr;", 
    "    my $hostinfo = gethostbyaddr($peeraddr);", 
    "    my $remote_host = $hostinfo->name || $ns->peerhost;", 
    "    my(@inetaddr) = unpack('C4', $peeraddr);", 
    "    print L \"$ns (CON) \", join('.', @inetaddr), ' = ',  $remote_host, \"\\n\";", 
    "", 
    "    if ($remote_host =~ /$AUTHORIZED_CLIENTS/i) {", 
    "", 
    "      CONNECTED:", 
    "\twhile (1) {", 
    "\t    my(@data) = ();", 
    "", 
    "\t  COMMAND:", 
    "\t    while (1) {", 
    "\t\t$_ = <$ns>;", 
    "\t\tlast CONNECTED unless defined $_;", 
    "\t\tlast COMMAND if /^$EOF$/;", 
    "\t\tpush @data, $_;", 
    "\t    } # whilend COMMAND", 
    "", 
    "\t    $_ = $data[0];", 
    "            print L \"$ns (CMD) $_\";", 
    "    ", 
    "\t  CASE: ", 
    "\t    {", 
    "\t\t/get_subnet_list/ and do { gsl $ns, @data; last CASE };", 
    "\t\t/get_subnet_file/ and do { gsf $ns, @data; last CASE };", 
    "\t\t/put_subnet_file/ and do { psf $ns, @data; last CASE };", 
    "\t\t/unl_subnet_file/ and do { usf $ns, @data; last CASE };", 
    "\t\tprint $ns \"1 Unknown command $_\";", 
    "\t    } # casend", 
    "", 
    "\t    print $ns \"$EOF\\n\";", 
    "\t} # whilend CONNECTED", 
    "    } else {", 
    "\tprint L \"ns (ERR) Unauthorized connect from '$remote_host'.\\n\";", 
    "\tprint $ns", 
    "\t  \"1 Connect from unauthorized host '$remote_host' refused.\\n$EOF\\n\";", 
    "    } # ifend legal host", 
    "", 
    "    print L \"$ns (DIS)\\n\";", 
    "    close L;", 
    "    close $ns;", 
    "    exit;", 
    "", 
    "} # end client_connect", 
    "", 
    "sub free_file {", 
    "", 
    "    # Close an id's file and release the lock object.", 
    "", 
    "    my($id) = @_;", 
    "", 
    "    if (exists $LOCKS{$id}) {", 
    "\t$LOCKS{$id}->[1]->close; # close subnet file", 
    "\tundef $LOCKS{$id}->[0];\t # free lock object", 
    "\tdelete $LOCKS{$id};", 
    "    }", 
    "", 
    "} # end free_file", 
    "", 
    "sub update_network_dbs {", 
    "", 
    "    # Compare subnet database files and SDBM last modification", 
    "    # dates. Lock recently changed files and update dhcpd.conf", 
    "    # and the named zone files.", 
    "", 
    "    opendir S, $SDB_PATH or warn \"Cannot open $SDB_PATH: $!\";", 
    "    my(@dirent) = grep /^.+\\.sdb$/, readdir S;", 
    "    closedir S;", 
    "", 
    "    while (my $subnet = shift @dirent) {", 
    "        $MODTIMES{$subnet} ||= 0;", 
    "        my $last_mod = (stat \"$SDB_PATH/$subnet\")[9];", 
    "        if ($last_mod > $MODTIMES{$subnet}) {", 
    "            print L \"Database $subnet has changed, update DHCP/DNS data.\\n\";", 
    "\t    $MODTIMES{$subnet} = $last_mod;", 
    "        }", 
    "    }", 
    "", 
    "    $SIG{ALRM} = \\&update_network_dbs;", 
    "    alarm 60;", 
    "", 
    "} # end update_network_dbs", 
    "", 
    "# IPADM command processors.", 
    "", 
    "sub gsl {", 
    "", 
    "    # Grab the first (Title) line from each subnet file.", 
    "", 
    "    my($ns, @data) = @_;", 
    "", 
    "    unless (opendir S, $SDB_PATH) {", 
    "\tprint $ns \"1 Cannot Read SDB Directory $SDB_PATH: $!.\\n\";", 
    "\treturn;", 
    "    }", 
    "    my(@dirent) = grep /^.+\\.sdb$/, sort(readdir S);", 
    "    closedir S;", 
    "    print $ns \"0 OK\\n\";", 
    " ", 
    "    while ($_ = shift @dirent) {", 
    "        open S, \"$SDB_PATH/$_\" or die \"Cannot open $_: $!\";", 
    "\tmy $title = <S>;", 
    "\t($title) = $title =~ /^\\s*Title\\s*=\\s*(.*)$/;", 
    "        print $ns \"$_ $title\\n\";", 
    "        close S;", 
    "    }", 
    "", 
    "} # end get_subnet_list", 
    "", 
    "sub gsf {", 
    "", 
    "    # Get a subnet file for a client.", 
    "", 
    "    my($ns, @data) = @_;", 
    "", 
    "    my $command = shift @data;", 
    "    my($c, $subnet, $id) = split ' ', $command;", 
    "", 
    "    free_file $id;", 
    "", 
    "    my $h = IO::Handle->new;", 
    "    die \"IO::Handle->new failed.\" unless defined $h;", 
    "    unless (open($h, \"+<$SDB_PATH/$subnet\")) {", 
    "\tprint $ns \"1 $subnet Open Failed: $!.\\n\";", 
    "\treturn;", 
    "    }", 
    "", 
    "    my $lock = LockFile->new(\"$SDB_PATH/$subnet\", $id, 10);", 
    "    $LOCKS{$id} = [$lock, $h];", 
    "", 
    "    if ($lock->have_lock) {", 
    "\tprint $ns \"0 Have Lock\\n\";", 
    "    } else {", 
    "\tmy $owner = $lock->owner;", 
    "\tmy $expire = $lock->free;", 
    "\tprint $ns \"2 Lock Failed $owner $expire\\n\";", 
    "    }", 
    "", 
    "    print $ns $h->getlines;\t# return the subnet data", 
    "", 
    "} # end get_subnet_file", 
    "", 
    "sub psf {", 
    "", 
    "    # Put a subnet file from a client.", 
    "", 
    "    my($ns, @data) = @_;", 
    "", 
    "    my $command = shift @data;", 
    "    my($c, $subnet, $id) = split ' ', $command;", 
    "", 
    "    unless (exists $LOCKS{$id}) {", 
    "\tprint $ns \"1 Lock Entry Missing for '$command'.\\n\";", 
    "\treturn;", 
    "    }", 
    "", 
    "    if ($LOCKS{$id}->[0]->check_my_lock) {", 
    "\tmy $h = $LOCKS{$id}->[1];", 
    "\tseek $h, 0, 0 or die \"seek failed: $!\";", 
    "\ttruncate $h, 0 or die \"truncate failed: $!\";", 
    "\tforeach (@data) {", 
    "\t    $h->print($_);", 
    "\t}", 
    "\tprint $ns \"0 Put Complete\\n\";", 
    "    } else {", 
    "\tprint $ns \"2 Put Failed Lock Lost\\n\";", 
    "    }", 
    "", 
    "    free_file $id;", 
    "", 
    "} # end put_subnet_file", 
    "", 
    "sub usf {", 
    "", 
    "    # Unlock a subnet file for a client.  Called after a", 
    "    # get_subnet_file, when put_subnet_file is not to be", 
    "    # called - i.e. subnet changes have been canceled.", 
    "", 
    "    my($ns, @data) = @_;", 
    "", 
    "    my $command = shift @data;", 
    "    my($c, $subnet, $id) = split ' ', $command;", 
    "", 
    "    unless (exists $LOCKS{$id}) {", 
    "\tprint $ns \"1 Lock Entry Missing for '$command'.\\n\";", 
    "\treturn;", 
    "    }", 
    "", 
    "    free_file $id;", 
    "    print $ns \"0 Unlock Complete.\\n\";", 
    "", 
    "} # end unlock_subnet_file!@#_currentPos!@#_anchor"
  ], 
  "set_selection": "false", 
  "version": "1.0.12", 
  "treat_as_ejs": "false", 
  "type": "snippet", 
  "indent_relative": "false", 
  "auto_abbreviation": "false"
}