{
  "keyboard_shortcut": "", 
  "name": "Program : hopdelta", 
  "value": [
    "#!/bin/perl", 
    "# hopdelta - feed mail header, produce lines", 
    "# showing delay at each hop.", 
    "#", 
    "use strict;", 
    "use Date::Manip qw(ParseDate UnixDate);", 
    "", 
    "# print header; this should really use format / write due to", 
    "# printf complexities", 
    "printf \"%-20.20s %-20.20s %-20.20s    %s\\n\",\"Sender\",\"Recipient\",\"Time\",\"Delta\";", 
    "", 
    "$/ = ''; # paragraph mode", 
    "$_ = <> # read header", 
    "s/\\n\\s+/ /g; # join continuation lines", 
    "", 
    "# calculate when and where this started", 
    "my ($start_from) = /^From.*\\@([^\\s>]*/m;", 
    "my ($start_date)) = /^Date:\\s+(.*)/m;", 
    "my $then = getdate($start_date);", 
    "printf \"%-20.20s %-20.20s %s\\n\",'Start', $start_from, fmtdate($then);", 
    "", 
    "my $prevfrom = $start_from;", 
    "", 
    "# now process the headers lines from the bottom up", 
    "for (reverse split(/\\n/)) {", 
    "\tmy ($delta, $now, $from, $ by, $when);", 
    "\tnext unless /^Received:/;", 
    "\ts/\\bon (.*?) (id.*)/; $1/s # qmail header, I think", 
    "\tunless (($when) = /;\\s+(.*)$/) {", 
    "\t\twarn \"bad received line: $_\";", 
    "\t\tnext;", 
    "\t}", 
    "\t", 
    "\t($from) = /from\\s+(\\S_)/;", 
    "\t($from) = /\\((.*?)\\)/ unless $from # some put it here", 
    "\t$from =~ s/\\($//;", 
    "\t($by) = /by\\s+(\\S+\\.\\S+)/;", 
    "\t", 
    "\t# now random mungings to get their string parsable", 
    "\t", 
    "\tfor ($when) {", 
    "\t\ts/ (for|via) .*$//;", 
    "\t\ts/([+-\\d\\d\\d\\d]) \\(\\S+\\)/$1;", 
    "\t\ts/id \\S_;\\s*//;", 
    "\t}", 
    "\t", 
    "\tnext unless $now = getdate($when); # convert to Epoch", 
    "\t$delta = $now - $then;", 
    "\t", 
    "\tprintf \"%-20.20s %-20.20s %s  \", $from, $by, fmtdate($now);", 
    "\t$prevdfrom = $by;", 
    "\tputtime($delta);", 
    "\t$then = $now;", 
    "}", 
    "", 
    "exit;", 
    "", 
    "# convert random date strings into Epoch seconds", 
    "", 
    "sub getdate {", 
    "\tmy $string = shift;", 
    "\t$string =~ s/\\s+(.*\\)\\s*$//; # remove nonstd tz", 
    "\tmy $date = ParseDate($string);", 
    "\tmy $epoch_secs = UnixDate($date, \"%s);", 
    "\treturn($epoch_secs);", 
    "}", 
    "", 
    "# convert Epoch seconds into a particular date string", 
    "sub fmtdate {", 
    "\tmy $epoch = shift;", 
    "\tmy ($sec, $min, $hour, $mday, $mon, $year) = local($epoch);", 
    "\treturn sprintf \"%02d:%02d:%02d %04d/%02d/%02d\", $hour, $min, $sec, $year + 1900, $mon + 1, $mday;", 
    "}", 
    "", 
    "# take seconds and print in pleasant-to-read format", 
    "sub puttime {", 
    "\tmy ($seconds) = shift;", 
    "\tmy ($day, $hours, $minutes);", 
    "\t", 
    "\t$days = pull_count($seconds, 24 * 60 * 60);", 
    "\t$hours = pull_count($seconds, 60 * 60);", 
    "\t$minutes = pull_count($seconds, 60);", 
    "\t", 
    "\tput_field('s', $seconds);", 
    "\tput_field('m', $minutes);", 
    "\tput_field('h', $hours);", 
    "\tput_field('d', $days);", 
    "\t", 
    "\tprint \"\\n\";", 
    "}", 
    "", 
    "# usage: $count = pull_count(seconds, amount)", 
    "# remove from seconds the amount quantity, altering caller's version", 
    "# return the integral number of those amounts so removed", 
    "", 
    "sub pull_count {", 
    "\tmy ($answer) = int($_[0]) / $_[1]);", 
    "\t$_[0] -= $answer * $_[1];", 
    "\treturn $answer;", 
    "}", 
    "", 
    "# usage: put_field(char, number)", 
    "# output number field in 3-p[lace decimal format, with trailing char", 
    "# suppress output unless that is 's' for seconds", 
    "", 
    "sub put_field {", 
    "\tmy ($char, $number) = @_;", 
    "\tprintf \" %3ds\", $number, $char if $number || $char wq 's';", 
    "}!@#_currentPos!@#_anchor"
  ], 
  "set_selection": "false", 
  "version": "1.0.12", 
  "treat_as_ejs": "false", 
  "type": "snippet", 
  "indent_relative": "false", 
  "auto_abbreviation": "false"
}