{
  "keyboard_shortcut": "", 
  "name": "Circular linked lists", 
  "value": [
    "{", 
    "\t# process", 
    "\t#\tThis package defines a process object.", 
    "\t", 
    "\tpackage process;", 
    "\t", 
    "\t# new - create a process object", 
    "\tsub new {", 
    "\t\tmy ( $class, $name, $state ) = @_;", 
    "\t\tmy $self = { name => $name, state => $state };", 
    "\t\treturn bless $self, $class;", 
    "\t}", 
    "\t", 
    "\t# link method - get or set the link to the next process", 
    "\t#\tUsage:", 
    "\t#\t\t$next = $proc->link;", 
    "\t#\tOr:", 
    "\t#\t\t$proc->link($other_proc);", 
    "\t", 
    "\tsub link {", 
    "\t\tmy $process = shift;", 
    "\t\treturn @_ ? ($process->{link = shift}) : $process->{link};", 
    "\t}", 
    "\t", 
    "\t# ... and a few other routines ...", 
    "}", 
    "", 
    "# Create the idle process.  It's state contains a program that", 
    "# loops forever, giving up its slice immediately each time.", 
    "$idle = new process(\"Idle\", $idle_state);", 
    "", 
    "# Create the \"Boot\" process, which loads some program in from", 
    "# disk, initializes and queues the process state for that", 
    "# progra, and then exits.", 
    "$boot = new process(\"Boot\", $boot_state);", 
    "", 
    "# Set up the circular link", 
    "$idle->link($boot);", 
    "$boot->link($idle);", 
    "", 
    "# and get ready to run, as if we just finished a slice for $idle", 
    "$pred = $boot;", 
    "$current_process = $idle;", 
    "$quit_cause = $SLICE_OVER;", 
    "", 
    "# Here's the scheduler - it never exits.", 
    "while (1) {", 
    "\tif ($quit_cause == $SLICE_OVER) {", 
    "\t\t# Move to the next process.\t\t", 
    "\t\t$pred = $current_process;", 
    "\t\t$current_process = $current_process->link;\t\t", 
    "\t} elsif ( $quit_cause == $IO_BLOCK ) {", 
    "\t\t# The current process has issued some I/O.", 
    "\t\t# Remove it from the list, and move on to the next", 
    "\t\t$next_process = $pred->link( $current_process->link );", 
    "\t\t# Add $current_process to a list for the I/O device.", 
    "\t\tIO_wait($current_process);\t\t", 
    "\t\t$current_process = $next_process;", 
    "\t} elsif ( $quit_cause == $IO_COMPLETE ) {", 
    "\t\t# Some I/O has completed - add the process", 
    "\t\t# waiting for it back into the list.", 
    "\t\t# If the current process is Idle, progress to", 
    "\t\t# the new process immediately.", 
    "\t\t# Otherwise, continue the current process until", 
    "\t\t# the end of its slice.", 
    "\t\t$io_process->link( $current_process );", 
    "\t\t$pred = $pred->link( $io_process );", 
    "\t} elsif ( $quit_cause = $QUIT ) {", 
    "\t\t# This process has completed - remove it from the list.", 
    "\t\t$next_process = $pred->link( $current_process->link );", 
    "\t\t$current_process = $next_process;", 
    "\t} elsif ( $quit_cause = $FORK ) {", 
    "\t\t# Fork a new process.  Put it at the end of the list.", 
    "\t\t$new_process = new process( $current_process->process_info );", 
    "\t\t$new_process->link( $current_process );", 
    "\t\t$pred = $pred->link( $new_process );", 
    "\t}", 
    "\t", 
    "\t# run the current process", 
    "\t$quit_cause = $current_process->run;", 
    "}!@#_currentPos!@#_anchor"
  ], 
  "set_selection": "false", 
  "version": "1.0.12", 
  "treat_as_ejs": "false", 
  "type": "snippet", 
  "indent_relative": "false", 
  "auto_abbreviation": "false"
}